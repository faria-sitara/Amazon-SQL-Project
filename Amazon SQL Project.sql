
-- 1. Top Selling Products
-- Query the top 10 products by total sales value.
-- Challenge: Include product name, total quantity sold, and total sales value.

SELECT * FROM order_items

ALTER TABLE order_items
ADD total_sale FLOAT;

UPDATE order_items
SET total_sale = quantity * price_per_unit

SELECT TOP 10 oi.product_id, p.product_name, SUM(oi.total_sale) AS total_sale, COUNT(o.order_id) as total_orders
FROM orders AS o
JOIN order_items AS oi
ON oi.order_id = o.order_id
JOIN products AS p
ON p.product_id = oi.product_id
GROUP BY oi.product_id, p.product_name
ORDER BY total_sale desc;

-- 2. Revenue by Category
-- Calculate total revenue generated by each product category.
-- Challenge: Include the percentage contribution of each category to total revenue.

SELECT p.category_id, c.category_name, SUM(oi.total_sale) AS total_sale, (SUM(oi.total_sale)/(SELECT SUM(total_sale) FROM order_items))*100 AS percentage_revenue 
FROM order_items AS oi
JOIN products AS p
ON p.product_id = oi.product_id
LEFT JOIN category AS c
ON p.category_id = c.category_id
GROUP BY p.category_id, c.category_name
ORDER BY total_sale DESC

-- 3. Average Order Value (AOV)
-- Compute the average order value for each customer.
-- Challenge: Include only customers with more than 5 orders.



SELECT c.customer_id, CONCAT(c.first_name, ' ', c.last_name) AS full_name, SUM(oi.total_sale)/COUNT(o.order_id) AS AOV, COUNT(o.order_id) as total_orders
FROM orders AS o
JOIN customers AS c
ON c.customer_id = o.customer_id
JOIN order_items AS oi
ON oi.order_id = o.order_id
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING COUNT(o.order_id) > 5
Order by 1

-- 4. Monthly Sales Trend
-- Query monthly total sales over the past year.
-- Challenge: Display the sales trend, grouping by month, return current_month sale, last month sale!

SELECT year, month, total_sale as current_sale, LAG(total_sale, 1) OVER(ORDER BY month) as last_month_sale
FROM (
    SELECT MONTH(order_date) AS month, 
           YEAR(order_date) AS year, 
           ROUND(SUM(oi.total_sale), 2) AS total_sale
    FROM orders AS o
    JOIN order_items AS oi
    ON oi.order_id = o.order_id
    WHERE order_date >= DATEADD(YEAR, -1, GETDATE())
    GROUP BY MONTH(order_date), YEAR(order_date)
) AS t1
ORDER BY month, year;

-- 5. Customers with No Purchases
-- Find customers who have registered but never placed an order.
-- Challenge: List customer details and the time since their registration.

SELECT *
FROM customers
WHERE customer_id NOT IN (SELECT DISTINCT(customer_id)
FROM orders)

-- 6. Least-Selling Categories by State
-- Identify the least-selling product category for each state.
-- Challenge: Include the total sales for that category within each state.

SELECT c.state, ca.category_name, SUM(oi.total_sale) as total_sale
FROM orders as o
JOIN customers as c
on o.customer_id = c.customer_id
JOIN order_items as oi
ON o.order_id = oi.order_id
JOIN products as p
ON oi.product_id = p.product_id
JOIN category as ca
ON ca.category_id = p.category_id
GROUP BY c.state, ca.category_name
ORDER BY 1, 3 DESC

-- 7. Customer Lifetime Value (CLTV)
-- Calculate the total value of orders placed by each customer over their lifetime.
-- Challenge: Rank customers based on their CLTV.

SELECT c.customer_id, CONCAT(c.first_name, ' ', c.last_name) AS full_name, SUM(oi.total_sale) as CLTV, DENSE_RANK() OVER(ORDER BY SUM(total_sale) DESC) as cx_ranking
FROM orders AS o
JOIN customers AS c
ON c.customer_id = o.customer_id
JOIN order_items AS oi
ON oi.order_id = o.order_id
GROUP BY c.customer_id, c.first_name, c.last_name

-- 8. Inventory Stock Alerts
-- Query products with stock levels below a certain threshold (e.g., less than 10 units).
-- Challenge: Include last restock date and warehouse information.

SELECT i.inventory_id, p.product_name, i.stock as current_stock, i.last_stock_date, i.warehouse_id
FROM inventory as i
JOIN products as p
ON p.product_id = i.product_id
WHERE stock < 10

-- 9. Shipping Delays
-- Identify orders where the shipping date is later than 3 days after the order date.
-- Challenge: Include customer, order details, and delivery provider.

SELECT c.*, o.*, s.*, DATEDIFF(DAY, o.order_date, s.shipping_date) AS days_between
FROM orders AS o
JOIN customers AS c
ON c.customer_id = o.customer_id
JOIN shipping AS s
ON s.order_id = o.order_id
WHERE DATEDIFF(DAY, o.order_date, s.shipping_date) > 3;

-- 10. Payment Success Rate 
-- Calculate the percentage of successful payments across all orders.
-- Challenge: Include breakdowns by payment status (e.g., failed, pending)

SELECT 
	payment_status, 
    COUNT(*) AS total_count, 
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM payments) AS percentage
FROM payments
GROUP BY payment_status;

-- 11. Top Performing Sellers
-- Find the top 5 sellers based on total sales value.
-- Challenge: Include both successful and failed orders, and display their percentage of successful orders.

WITH top_sellers AS (
    SELECT TOP 5 s.seller_id, s.seller_name, SUM(oi.total_sale) AS total_sale 
    FROM orders AS o
    JOIN sellers AS s ON o.seller_id = s.seller_id
    JOIN order_items AS oi ON oi.order_id = o.order_id
    GROUP BY s.seller_id, s.seller_name
    ORDER BY SUM(oi.total_sale) DESC
),
sellers_report AS (
    SELECT o.seller_id, ts.seller_name, o.order_status, COUNT(*) AS order_count
    FROM orders AS o
    JOIN top_sellers AS ts ON ts.seller_id = o.seller_id
    WHERE o.order_status NOT IN ('Inprogress', 'Returned')
    GROUP BY o.seller_id, ts.seller_name, o.order_status
)
SELECT seller_id, 
       seller_name, 
       SUM(CASE WHEN order_status = 'Completed' THEN order_count ELSE 0 END) AS Completed_orders,
       SUM(CASE WHEN order_status = 'Cancelled' THEN order_count ELSE 0 END) AS Cancelled_orders,
       SUM(order_count) AS total_orders,
       CAST(SUM(CASE WHEN order_status = 'Completed' THEN order_count ELSE 0 END) AS FLOAT) / 
       CAST(SUM(order_count) AS FLOAT) * 100 AS successful_orders_percentage
FROM sellers_report
GROUP BY seller_id, seller_name
ORDER BY seller_id, seller_name;




-- 12. Product Profit Margin
-- Calculate the profit margin for each product (difference between price and cost of goods sold).
-- Challenge: Rank products by their profit margin, showing highest to lowest.

Select p.product_id, p.product_name, SUM(total_sale - (p.cogs * oi.quantity)) as profit, (SUM(total_sale - (p.cogs * oi.quantity))/SUM(total_sale)) * 100 as profit_margin, DENSE_RANK() OVER(ORDER BY (SUM(total_sale - (p.cogs * oi.quantity))/SUM(total_sale)) * 100 DESC) as product_rank
from order_items as oi
JOIN products as p
ON oi.product_id = p.product_id
GROUP BY p.product_id, p.product_name


-- 13. Most Returned Products
-- Query the top 10 products by the number of returns.
-- Challenge: Display the return rate as a percentage of total units sold for each product.

SELECT TOP 10
    p.product_id, 
    p.product_name, 
    SUM(oi.quantity) AS total_units_sold, 
    SUM(CASE WHEN o.order_status = 'Returned' THEN oi.quantity ELSE 0 END) AS total_units_returned, 
    CAST(SUM(CASE WHEN o.order_status = 'Returned' THEN oi.quantity ELSE 0 END) AS FLOAT) / 
    CAST(SUM(oi.quantity) AS FLOAT) * 100 AS return_percentage
FROM order_items AS oi
JOIN products AS p ON oi.product_id = p.product_id
JOIN orders AS o ON o.order_id = oi.order_id
GROUP BY p.product_id, p.product_name
ORDER BY return_percentage DESC;


-- 14. Inactive Sellers
-- Identify sellers who haven’t made any sales in the last 6 months.
-- Challenge: Show the last sale date and total sales from those sellers.

WITH cte1 AS (
    -- Sellers who have not made any sales in the last 6 months
    SELECT * 
    FROM sellers
    WHERE seller_id NOT IN (
        SELECT seller_id 
        FROM orders 
        WHERE order_date >= DATEADD(MONTH, -6, CAST(GETDATE() AS DATE))
    )
)
SELECT 
    o.seller_id,
    cte1.seller_name,
    MAX(o.order_date) AS last_sale_date,
    SUM(oi.total_sale) AS total_sale_amount
FROM orders AS o
JOIN cte1 ON cte1.seller_id = o.seller_id
JOIN order_items AS oi ON o.order_id = oi.order_id
GROUP BY o.seller_id, cte1.seller_name;

-- 15. Top 10 product with highest decreasing revenue ratio compare to last year(2022) and current_year(2023)
-- Challenge: Return product_id, product_name, category_name, 2022 revenue and 2023 revenue decrease ratio at end Round the result
-- Note: Decrease ratio = cr-ls/ls* 100 (cs = current_year ls=last_year)

WITH last_year_sale AS (
    SELECT 
        p.product_id, 
        p.product_name, 
        SUM(oi.total_sale) AS revenue_2022
    FROM orders AS o
    JOIN order_items AS oi ON o.order_id = oi.order_id
    JOIN products AS p ON p.product_id = oi.product_id
    WHERE YEAR(o.order_date) = 2022
    GROUP BY p.product_id, p.product_name
),

current_year_sale AS (
    SELECT 
        p.product_id, 
        p.product_name, 
        SUM(oi.total_sale) AS revenue_2023
    FROM orders AS o
    JOIN order_items AS oi ON o.order_id = oi.order_id
    JOIN products AS p ON p.product_id = oi.product_id
    WHERE YEAR(o.order_date) = 2023
    GROUP BY p.product_id, p.product_name
)

SELECT TOP 10
    ls.product_id,
	ls.product_name,
    ls.revenue_2022 AS last_year_revenue,
    cs.revenue_2023 AS current_year_revenue,
    ls.revenue_2022 - cs.revenue_2023 AS rev_diff,
    ROUND(CAST(cs.revenue_2023 - ls.revenue_2022 AS FLOAT) / CAST(ls.revenue_2022 AS FLOAT) * 100, 2) AS revenue_dec_ratio
FROM last_year_sale AS ls
JOIN current_year_sale AS cs
    ON ls.product_id = cs.product_id
WHERE 
    ls.revenue_2022 > cs.revenue_2023
ORDER BY revenue_dec_ratio DESC


-- 16. Store Procedure
-- create a function as soon as the product is sold the the same quantity should reduced from inventory table
-- after adding any sales records it should update the stock in the inventory table based on the product and qty purchased

SELECT * FROM inventory
WHERE product_id = 1; -- airpod 3rd gen 55 stock

CREATE PROCEDURE add_sales
(
    @p_order_id INT,
    @p_customer_id INT,
    @p_seller_id INT,
    @p_order_item_id INT,
    @p_product_id INT,
    @p_quantity INT
)
AS
BEGIN
    -- Declare all variables
    DECLARE @v_count INT;
    DECLARE @v_price FLOAT;
    DECLARE @v_product VARCHAR(50);

    -- Fetching product name and price based on product ID
    SELECT 
        @v_price = price, 
        @v_product = product_name
    FROM products
    WHERE product_id = @p_product_id;
    
    -- Checking stock and product availability in inventory
    SELECT 
        @v_count = COUNT(*) 
    FROM inventory
    WHERE 
        product_id = @p_product_id
        AND 
        stock >= @p_quantity;

    IF @v_count > 0
    BEGIN
        -- Add into orders and order_items tables
        -- Insert into orders
        INSERT INTO orders(order_id, order_date, customer_id, seller_id)
        VALUES
        (@p_order_id, GETDATE(), @p_customer_id, @p_seller_id);

        -- Add into order_items
        INSERT INTO order_items(order_item_id, order_id, product_id, quantity, price_per_unit, total_sale)
        VALUES
        (@p_order_item_id, @p_order_id, @p_product_id, @p_quantity, @v_price, @v_price * @p_quantity);

        -- Update inventory
        UPDATE inventory
        SET stock = stock - @p_quantity
        WHERE product_id = @p_product_id;

        -- Print the message
        PRINT 'Thank you! Product: ' + @v_product + ' sale has been added and inventory stock updated.';
    END
    ELSE
    BEGIN
        -- Print the message for unavailable product
        PRINT 'Thank you for your info, the product: ' + @v_product + ' is not available.';
    END
END;
GO

-- Example call to the procedure
EXEC add_sales 25006, 2, 5, 25004, 1, 14;





